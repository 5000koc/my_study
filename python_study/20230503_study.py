# -*- coding: utf-8 -*-
"""20230503_study.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aav8j63prNz9UwsMMSKhMTEE87KM7Imh
"""

# add_all(1,2,3,4,5,6,7,9,10) 전부 더해서 55가 나오게 해라 (*args를 input으로 받으시오)

add_all = [1,2,3,4,5,6,7,8,9,10]

def add_all(*inputs):
    s = 0
    for i in range(len(inputs)):
        s += inputs[i]

    return s

def add_all2(*inputs):
    return sum()

def add_all3(*args)
    s = 0
    for i in args:
        for j in i:
            s += j
        return s

def add_all4(*args):
  temp = 0
  for i in range(len(args)):
      if type(args[i]) == list:
          for j in args[i]:
              temp += j
      else:
          temp += args[i]
  return temp

"""list는 그 자체가 오브젝트로 구성이 되지만, array는 리스트 내용 하나하나가 오브젝트로 구성이 됨
그래서 불러오기가 오브젝트 전체를 불러오는 리스트에 비해서 빠름
"""

# 넘피 버전 확인

import numpy as np
print(np.__version__)

A = [1,2,3,4]

a = np.array(A, np.int)
print(type(a))
print(a)

import numpy as np
A = [1,2,3,4]
a = np.array(A)
s = a[:2]
print(type(s))
print('A의 출력입니다.%a' %a)
print('s의 출력입니다.%s' %s)

"""Ndarray 타입을 검색하거나 슬라이싱은 참조만 할당하므로"""

ss = a[:2].copy()
print(ss.size)
ss[0] = 99
print(a)
print(s)
print(ss)

"""벡터화
배열을 for문을 작성하지 않고 데이터를 일괄처리하는 것

브로드캐스팅
다른 모양의 배열 간의 산술연산을 수행 할 수 있도록 해주는 numpy의 기능
"""

arr = np.array([[1,2,3],[4,5,6]])
arr

arr+arr

10 - arr

arr * 3

arr / 3

arr2 = np.array([100,200,300])

arr4 = np.array([[100],[200],[300]])
arr4

arr + arr4

arr3 = np.array([100,200])

arr + arr3

arr + arr2

arr = np.zeros((3,2))
arr

arr.flatten() # 1D vector로 만드는 것

arr = np.array([[1,2],[3,4]])
arr.flatten()

"""reshape
이미 존재하는 배열을 원하는대로 shape을 조정을 함
"""

arr = np.arange(12)
arr

arr.reshape(3,4) # 주어진 shape의 약수로 이루어진 shape만 가능



arr.reshape(4,3)
arr.reshape(1,12) # =flatten()
arr.reshape(12,1)
arr.reshape(2,6)
arr.reshape(6,2)

arr = np.arange(20)
arr

arr.reshape(-1,5)

arr.reshape(5,-1)

arr = np.arange(20).reshape(4,5)
arr

print(arr.transpose().shape)
arr.transpose()

arr = np.arange(30).reshape(3,2,5)
arr.shape

arr.transpose().shape

arr.T

x = np.arange(6).reshape(-1,3)
x

x.T

# 0 ~ 20 까지의 숫자 배열을 만든 다음에 arr1은 짝수, arr2는 홀수가 들어간 배열을 출력해보자
import numpy as np

arr = np.arange(0, 21)
arr1 = []
arr2 = []
for i in arr:
    if arr[i] % 2 == 0:
        arr1.append(arr[i])
    else:
        arr2.append(arr[i])

import numpy as np
Arr = np.arange(0,21)

Arr1 = Arr[Arr % 2 == 0]
Arr2 = Arr[Arr % 2 != 0]

print(Arr1)
print(Arr2)

arr1d = np.arange(8)

arr1d[1]

arr1d[-1]

arr1d[:4]

"""브로드캐스팅"""

lst = list(range(6))
lst

lst[2:5] = -1
lst

lst[3] = -1
lst

arr1d = np.arange(8)
arr1d

arr1d[3:6] = 100
arr1d

"""view"""

arr2d = np.arange(20).reshape(4,-1)
arr2d

arr2d[0] # 첫번째 행

arr2d[1][2] # 재귀적 접근 / 1행 2열

arr2d[1,2] # 콤마를 이용하여 인덱싱을 할 수 있음

arr2d[:3,:2] #행과 열을 접근하기 위해 컴마로 연결

"""불리안 배열"""

arr = np.array([0,1,2,3,4])
arr[[True,False,True,False,True]]

"""정수 배열을 사용한 인덱싱"""

arr2d = np.arange(20).reshape(4,5)
arr2d

arr2d[[0,2]] # 0행과 2행 multi index는 [] 하나 더 추가

arr2d[[0,3],[4]]

arr2d[[0,1],[4,3]]

arr2d[[0,1,2],[4,3,1]]

"""유니버설 함수"""

arr = np.arange(-3,3).reshape(3,-1)
arr

np.exp(arr)

"""- floor : 소수점 버리기"""

np.floor(arr)

"""이항 유니버설 함수"""

arr1 = np.arange(8).reshape(2,-1)
arr2 = np.arange(-40,40,10).reshape(2,-1)
print(arr1)
print(arr2)

np.maximum(arr1,arr2) # 같은 원소에서 가장 큰 값

np.subtract(arr1,arr2) # 같은 원소끼리 뺄셈

np.multiply(arr1,arr2) # 같은 원소끼리 곱셈

"""통계 메소드"""

arr = np.arange(4).reshape(2,2)
arr

arr.sum()

arr.sum(axis = 0)

arr.sum(axis = 1)

arr.mean()

arr.mean(axis = 1)

arr.mean(axis = 0)

"""- where
 - x if 조건 else y의 벡터화 버전
 - numpy를 사용하여 배열을 빠르게 처리할 수 있으며, 다차원도 간결하게 표현가능
"""

xarr = np.array([100,200,300,400])
yarr = np.array([1,2,3,4])
cond = np.array([True,False,True,False])

result = np.where(cond,xarr,yarr)
result

np.where(xarr > 200, max(xarr), 0)

np.where(xarr % 3 == 0,1,0)

"""- sort()"""

np.random.seed(42)
arr = np.random.randint(1,100,size=10) # 1~100까지의 정수 중에 10개를 뽑아주세요
arr

arr.sort()

arr

-np.sort(-arr)

"""-array의 sort에서는 내림차순, 오름차순을 선택하는 옵션이 없다"""

lst = [1,32,4,1,20]
lst.sort(reverse = True)
lst

"""- 선형대수 패키지

- 단위행렬
- 대각선 원소 1이고, 나머지는 0인 n차 정방행렬을 말하며, numpy의 eye()함수를 사용하여 만들 수 있음
"""

import numpy as np
identity = np.eye(4)
print(identity)

identity = np.eye(2,3)
print(identity)

x = np.arange(9).reshape(3,-1)
print(x)

np.diag(x)

np.diag(np.diag(x))

"""- dot
- 원소간의 곱(element-wise product)
- 벡터의 내적(행렬의 곱)(벡터를 곱함)
"""

a = np.arange(4).reshape(-1,2)
print(a)

a*a # dot product

np.multiply(a,a)

np.dot(a,a) # 행렬의 곱

a.dot(a)

"""- matmul : matrix multiplication"""

a = np.random.randint(-3,3,10).reshape(2,5)
b = np.random.randint(0,5,15).reshape(5,3)
a.shape,b.shape

ab = np.matmul(a,b)
print(ab.shape,'\n') #\n 개행
print(ab)

np.dot(a,b) # dot -> 1차원 벡터 공식문서에는 2D차원(2차원) matmul로 돌아감.

"""- Pandas 수업 시작"""

import numpy as np
import pandas as pd

# Pandas 명령식

obj = pd.Series([0,1,2,3,4,5,6,7], index = ['a','b','c','d','e','f','g','h'],dtype = 'int64')
obj

"""- integer=location based"""

obj[3] # 슬라이싱 가능

obj[-1] # 슬라이싱 가능

obj[[1,3,5]] # multi index 접근방법

obj[1:3]

obj[obj < 3] # boolen indexing

- label location based

obj

obj.c

obj['c']

obj[['e','c']] # 멀티 인덱싱

obj['a':'d']

obj['d':'e'] = 100 # 브로드캐스팅
obj

"""- integer-location based"""

# Pandas 명령식

obj = pd.Series([0,1,2,3,4,5,6,7], index = ['a','b','c','d','e','f','g','h'],dtype = 'int64')
obj

obj.iloc[2]

obj.iloc[[2]]

obj.iloc[1:4]

"""- location based"""

obj.loc['a':'c']

# DataFrame 명령식

df = pd.DataFrame(np.arange(24).reshape(4,-1),columns = ['c1','c2','c3','c4','c5','c6'],
                                              index = ['r1','r2','r3','r4'])
df

df['c3']

df.c3

df[['c1','c3']] # 2개의 값으로 가져올 때는 [[]] 멀티인덱스로 가져오기

df['r1':'r2']

df['c1':'c2'] # 컴퓨터의 처리방식이 열(세로) 중심이라는 것에 의해 처리가 된 결과

df[['c1','c2']] # 행(가로)만 있을 때는 멀티인덱스를 통해서 가져오는 것이 가능

"""- iloc = integer location"""

df.iloc[[0],[3]]

df.iloc[[0,1],1:4]

df.loc[['r1'],['c4']]

df.loc['r1':'r2',['c2','c3','c4']]

df.loc['r1':'r2',['c3','c4','c2']]

"""- 산술연산자"""

s1 = pd.Series([1,2,3,4], index = ['a','b','c','d'])
s2 = pd.Series([10,20,30,40], index = ['a','b','c','d'])

s1+s2

s1 = pd.Series([1,2,3,4], index = ['a','b','c','d'])
s2 = pd.Series([10,20,30,40], index = ['b','c','d','e'])
            # SQL의 Outer Join
s1+s2       # NaN 이 나오는 이유는 s1과 s2 인덱스에 겹치는 것이 없는 부분이라서 Nan이 나옴

s1.add(s2,fill_value = 0)

s1.add(s1,fill_value = 0)

import pandas as pd
stock = pd.read_csv('/content/drive/MyDrive/stock_2020_01.csv', encoding='CP949')
stock

stock.head(6) # 위에서부터 자료를 읽음 기본은 5이지만, ()에 넣는 숫자만큼 읽어들임

stock.tail() # 밑에서부터 읽어들임 head()와 나머지 동일

stock.describe() # 갯수/평균/표준편차/작은값/25%/50%(median 데이터의 50%가 되는 지점)/75%/최고값

"""- 결측치 확인(missing value)"""

stock.isna().sum()
# stock.isnull().sum() 같은 명령어

"""- 데이터의 자료형 -> info()"""

stock.info()

stock['Date']

stock['kospi'].sort_values()

stock.unique()

"""- unique
- 중복되는 값을 제거하고 유일한 값만 담고 있는 Series를 반환
"""

obj = pd.Series([2,1,3,3,1,5,np,nan,1,2])  #nan : Not a Number
obj

"""- value_counts"""

obj.value_counts()

obj.sort_values()

obj.value_counts(normalize = True)

obj = pd.Series([1,2,3,-1,-2], index = list('abedc')) # list에 한글입력을 지원함
obj

obj.sort_index(ascending = False)

frame = pd.DataFrame(np.arange(9).reshape(3,3),
                     index = list('abc'),
                     columns = list('edf'))
frame

frame.sort_index(axis = 1)

frame.mean()

frame.sort_index(axis = 1)

frame.sort_values(by = 'e',ascending = False)

frame.sort_values(by = ['e','f'] ,ascending = [False,True])

"""- map
- Series의 각각의 element들을 다른 어떤 값을 대체하는 역할
"""

series = pd.Series([100,200,300])
series

series.map({100:'C', 200:'B', 300:'A'})

series.map('${}'.format)

series.map('{}달러'.format)

f = lambda x: np.add(x,3)
series.map(f)

"""- apply
- map보다 적용할 수 있는 범위가 큰 것
"""

s = pd.Series([20,21,12], index = ['London', 'NewYork', 'Helsinki'])
s

def sub_custom_values(x, val):
  return x - val

s.apply(sub_custom_values,args=(10, ))

def add_custom_values(x,**kwargs):
    for month in kwargs:
      print(month)
        x +=kwargs[month]
    return x

s.apply(add_custom_values, june=30, july=20, august=25)